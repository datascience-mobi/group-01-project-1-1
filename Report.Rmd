---
title: "Project 01.01 Report"
author: "Annika Hein, Amanda Janzen, Nicolai Laufer, Niklas Schwan"
date: "25/06/2019"
output: html_document
---
# Introduction

In this project we tried to identify genetic interactions and their effects on several Glioblastoma multiforme (GBM) cell lines. 

GBM is a fast growing, malignant brain tumor classified as a grade IV cancer by the World Health Organisation (WHO). It represents about 15% of all brain tumors and most commonly develops in adults aged 45-70. We chose GBM because it falls in the category of cancers with poor diagnosis and also has no effective long-term treatments, which leads to a survival rate of less than 15 months, according to the TCGA (The Cancer Genome Atlas Research Network).

The identification of genomic interactions and their effect on cancer cell survival is very important for the search after a better treatment. Its concept is tied to the fact that cancer is a product of accumulated genomic defects (mutations, copy number changes, etc.). There are a handful of genes that drive the process of oncogenesis, these are called *driver mutations* (DM), all other mutations that don't really have an impact on the oncogenisis are called *passenger mutations*.

The driver mutations are normally highly essential genes for all cells in the human body, making them a bad target for anti-cancer drugs, for they would shut down all cells, not just cancer cells. The alternative to this targeting problem is to find genes that are linked with the driving mutations in the cancer cells, but not in the normal cells. Ideally, the targeting of these so called *second site targets* (SST) would cause the cancer cells to shut down and stop proliferating, while the normal cells would not be subjected to any changes.

Our aim in this project was to find the driver mutations in GBM throughout all cell lines in our data set, compare them to the literature and investigate if there is a dependency between them and any second site targets. In the end the aim was to find a model where we could possibly predict a second site mutation based on the existence of a driving mutation.

# Data cleanup

Once we downloaded the data, we first removed all data that didn't have to do with Glioblastoma.

```{r}
allDepMapData = readRDS("/Users/Amanda/Desktop/DepMap19Q1_allData.RDS")
brain.anno = allDepMapData$annotation[allDepMapData$annotation$Subtype.Disease == "Glioblastoma", ]
```
Then we made the cell line identifiers be the rownames in the annotation.

```{r}
rownames(brain.anno) = brain.anno$DepMap_ID
brain.anno = brain.anno[, -1]
```
The next step was to remove all cell lines that were irrelevant to our project from all the other matrices (expression, copy number, relevant mutations, ceres and probability)

Package "operators" needed.

```{r}
library("operators")
cell.lines = dput(rownames(brain.anno))
exp.clean = allDepMapData$expression[, -which(colnames(allDepMapData$expression) %!in% cell.lines)]
copy.clean = allDepMapData$copynumber[, -which(colnames(allDepMapData$copynumber) %!in% cell.lines)]
relevant.mutations = subset(allDepMapData$mutation, names(allDepMapData$mutation) %in% cell.lines)
ceres.clean = allDepMapData$kd.ceres[, -which(colnames(allDepMapData$kd.ceres) %!in% cell.lines)]
prob.clean = allDepMapData$kd.prob[, -which(colnames(allDepMapData$kd.prob) %!in% cell.lines)]
```

After we separated all glioblastoma cell lines, we removed the NA and all values out of range. The data contained a lot of 0 and negative values, especially the copy number data, where x>=0.

```{r}
sum(is.na(ceres.clean))
sum(is.na(prob.clean))
sum(is.na(copy.clean))
sum(is.na(exp.clean))
sum(is.na(relevant.mutations))
copy.clean = copy.clean[-which(apply(copy.clean, 1, function(x) {sum(is.na(x))}) > 0), ]
sum(is.na(copy.clean))
```
The function sum() was used to show how many NA values were in each matrix.

* ceres.clean -> 0
* prob.clean -> 0 
* copy.clean -> 1780
* exp.clean -> 0
* relevant.mutations -> 0, but looking directly in the matrix we can see NA values.

```{r}
copy.clean = copy.clean[-which(apply(copy.clean, 1, function(x) {sum(is.na(x))}) > 0), ]
sum(is.na(copy.clean))
```

* copy.clean -> 0

The next cleanup target was probability matrix. It should only contain values between 0 and 1, which is the case.

```{r}
sum(prob.clean < 0) 
sum(prob.clean > 1) 
``` 

Checking for values = 0

```
sum(ceres.clean == 0) 
sum(prob.clean == 0) 
sum(copy.clean == 0) 
sum(exp.clean == 0)
```

ceres.clean -> 28
prob.clean -> 80
copy.clean -> 0
exp.clean -> 644705

Scan for outliers via boxplots and threshold or remove them if necessary.

Two values were identified an outliers, then thresholded and removed them.

```{r}
boxplot(ceres.clean) 
ceres.transf = ceres.clean[-which(ceres.clean > 3), ] 
```

Organising all matrices for further work. 

We compared the gene data availability between all data sets to get the same dimensions and also made all data nominal in the annotation.

```{r}
dim(copy.clean) == dim(exp.clean)
gene.data.co = c(rownames(copy.clean))
gene.data.ex = c(rownames(exp.clean))
exp.clean = exp.clean[-which(rownames(exp.clean) %!in% gene.data.co),]
copy.clean = copy.clean[-which(rownames(copy.clean) %!in% gene.data.ex),]
genes.clean = rownames(exp.clean)
ceres.clean = ceres.clean[-which(rownames(ceres.clean) %!in% genes.clean),]
prob.clean = prob.clean[-which(rownames(prob.clean) %!in% genes.clean),]
genes.clean = rownames(ceres.clean)
exp.clean = exp.clean[-which(rownames(exp.clean) %!in% genes.clean),]
copy.clean = copy.clean[-which(rownames(copy.clean) %!in% genes.clean),]
rm(gene.data.co)
rm(gene.data.ex)

brain.anno$CCLE_Name = factor(brain.anno$CCLE_Name)
brain.anno$Aliases = factor(brain.anno$Aliases)
brain.anno$Primary.Disease = factor(brain.anno$Primary.Disease)
brain.anno$Subtype.Disease = factor(brain.anno$Subtype.Disease)
brain.anno$Subtype.Gender = factor(brain.anno$Gender)
brain.anno$Subtype.Source = factor(brain.anno$Source)
```
dimensions: 16970x28

We also put the gene names and cell lines in alphabetical order

```{r}
ceres.clean = ceres.clean[order(rownames(ceres.clean)), order(colnames(ceres.clean))]
prob.clean = prob.clean[order(rownames(prob.clean)), order(colnames(prob.clean))]
exp.clean = exp.clean[order(rownames(exp.clean)), order(colnames(exp.clean))]
copy.clean = copy.clean[order(rownames(copy.clean)), order(colnames(copy.clean))]
```

In order to find all most commonly mutated genes among all relevant cell lines, we made a list with all commonly mutated genes and also combined all mutation matrices into one.

```{r}
#common.genes = as.data.frame(table(c(relevant.mutations$`ACH-000036`$Hugo_Symbol,relevant.mutations$`ACH-000040`$Hugo_Symbol, relevant.mutations$`ACH-000075`$Hugo_Symbol, relevant.mutations$`ACH-000098`$Hugo_Symbol, relevant.mutations$`ACH-000208`$Hugo_Symbol, relevant.mutations$`ACH-000215`$Hugo_Symbol, relevant.mutations$`ACH-000137`$Hugo_Symbol, relevant.mutations$`ACH-000152`$Hugo_Symbol, relevant.mutations$`ACH-000591`$Hugo_Symbol, relevant.mutations$`ACH-000673`$Hugo_Symbol, relevant.mutations$`ACH-000231`$Hugo_Symbol, relevant.mutations$`ACH-000244`$Hugo_Symbol, relevant.mutations$`ACH-000760`$Hugo_Symbol, relevant.mutations$`ACH-000368`$Hugo_Symbol, relevant.mutations$`ACH-000376`$Hugo_Symbol, relevant.mutations$`ACH-000445`$Hugo_Symbol, relevant.mutations$`ACH-000464`$Hugo_Symbol, relevant.mutations$`ACH-000469`$Hugo_Symbol, relevant.mutations$`ACH-000479`$Hugo_Symbol, relevant.mutations$`ACH-000570`$Hugo_Symbol, relevant.mutations$`ACH-000571`$Hugo_Symbol, relevant.mutations$`ACH-000623`$Hugo_Symbol, relevant.mutations$`ACH-000631`$Hugo_Symbol, relevant.mutations$`ACH-000738`$Hugo_Symbol, relevant.mutations$`ACH-000756`$Hugo_Symbol, relevant.mutations$`ACH-000819`$Hugo_Symbol, relevant.mutations$`ACH-000128`$Hugo_Symbol, relevant.mutations$`ACH-000887`$Hugo_Symbol)))#

relevant.mutations.combi = do.call(rbind, lapply(which(names(allDepMapData$mutation) %in% cell.lines), function(a) allDepMapData$mutation[[a]]))
common.genes = as.matrix(table(c(relevant.mutations.combi$Hugo_Symbol)))

summary(common.genes)
```

Commonly mutated genes:

* MT-ND5 (mitochondrially encoded NADH: ubiquinone oxireductase core subunit 5): 32
* TTN (titin, large abundant protein of striated muscle): 26
* MUC16 (mucin): 23
* MT-CYB (mitochondrially encoded cytochrome b): 18
* PTEN (phosphatase and tensin homolog): 17
* other: 10096
 
```{r}
common.genes = as.matrix(common.genes)
#rownames(common.genes) = common.genes$Var1
#common.genes$Var1 = NULL
barplot(common.genes, beside = T, names.arg = rownames(common.genes), las = 2)
common.genes.c = subset(common.genes, common.genes >11)
common.genes.c = common.genes.c[c(6, 11, 10, 7, 4, 9, 3, 2, 1, 8),]
barplot_commongenes <- barplot(common.genes.c, beside = T, names.arg = rownames(common.genes.c), ylab = "Frequency", main = "Most common gene mutations", las = 2)
```

Combine the mutation matrices of the GBM cell lines, extract the relevant columns "Hugo_Symbol", "IsDeleterious" and "DepMap_ID"  
Package dplyr needed for this step

```{r}
library(dplyr)
mutations.all = rbind(relevant.mutations$`ACH-000036`,relevant.mutations$`ACH-000040`, relevant.mutations$`ACH-000075`, relevant.mutations$`ACH-000098`, relevant.mutations$`ACH-000208`, relevant.mutations$`ACH-000215`, relevant.mutations$`ACH-000137`, relevant.mutations$`ACH-000152`, relevant.mutations$`ACH-000591`, relevant.mutations$`ACH-000673`, relevant.mutations$`ACH-000231`, relevant.mutations$`ACH-000244`, relevant.mutations$`ACH-000760`, relevant.mutations$`ACH-000368`, relevant.mutations$`ACH-000376`, relevant.mutations$`ACH-000445`, relevant.mutations$`ACH-000464`, relevant.mutations$`ACH-000469`, relevant.mutations$`ACH-000479`, relevant.mutations$`ACH-000570`, relevant.mutations$`ACH-000571`, relevant.mutations$`ACH-000623`, relevant.mutations$`ACH-000631`, relevant.mutations$`ACH-000738`, relevant.mutations$`ACH-000756`, relevant.mutations$`ACH-000819`, relevant.mutations$`ACH-000128`, relevant.mutations$`ACH-000887`$Hugo_Symbol)
mutations.all = select_(mutations.all, c(2,21, 36))
```

After that, we determined the GBM cells lines, which contained our four most prominent driver mutations (DM). We then extracted the cell lines which contain one specific mutation (MT-ND5, MUC16, TP53 and TTN) and determined the mean expression, copy number (CN), CERES score and probability of all genes over these cell lines.

* For MT-ND5:
```{r}
list.mtnd5 = unique(subset(mutations.all, mutations.all$Hugo_Symbol == "MT-ND5"))
cells.mtnd5 = c(list.mtnd5$DepMap_ID)
exp.mtnd5 = exp.clean[,which(colnames(exp.clean) %in% cells.mtnd5)]
copy.mtnd5 = copy.clean[,which(colnames(copy.clean) %in% cells.mtnd5)]
ceres.mtnd5 = ceres.clean[,which(colnames(ceres.clean) %in% cells.mtnd5)]
prob.mtnd5 = prob.clean[,which(colnames(prob.clean) %in% cells.mtnd5)]
mtnd5.exp.mean = as.matrix(c(rowMeans(exp.mtnd5)))
mtnd5.copy.mean = as.matrix(c(rowMeans(copy.mtnd5)))
mtnd5.ceres.mean = as.matrix(c(rowMeans(ceres.mtnd5)))
mtnd5.prob.mean = as.matrix(c(rowMeans(prob.mtnd5)))
```

* For MUC16:
```{r}
list.muc16 = unique(subset(mutations.all, mutations.all$Hugo_Symbol == "MUC16"))
cells.muc16 = c(list.muc16$DepMap_ID)
exp.muc16 = exp.clean[,which(colnames(exp.clean) %in% cells.muc16)]
copy.muc16 = copy.clean[,which(colnames(copy.clean) %in% cells.muc16)]
ceres.muc16 = ceres.clean[,which(colnames(ceres.clean) %in% cells.muc16)]
prob.muc16 = prob.clean[,which(colnames(prob.clean) %in% cells.muc16)]
muc16.exp.mean = as.matrix(c(rowMeans(exp.muc16)))
muc16.copy.mean = as.matrix(c(rowMeans(copy.muc16)))
muc16.ceres.mean = as.matrix(c(rowMeans(ceres.muc16)))
muc16.prob.mean = as.matrix(c(rowMeans(prob.muc16)))
```
* For TP53:
```{r}
list.tp53 = unique(subset(mutations.all, mutations.all$Hugo_Symbol == "TP53"))
cells.tp53 = c(list.tp53$DepMap_ID)
exp.tp53 = exp.clean[,which(colnames(exp.clean) %in% cells.tp53)]
copy.tp53 = copy.clean[,which(colnames(copy.clean) %in% cells.tp53)]
ceres.tp53 = ceres.clean[,which(colnames(ceres.clean) %in% cells.tp53)]
prob.tp53 = prob.clean[,which(colnames(prob.clean) %in% cells.tp53)]
tp53.exp.mean = as.matrix(c(rowMeans(exp.tp53)))
tp53.copy.mean = as.matrix(c(rowMeans(copy.tp53)))
tp53.ceres.mean = as.matrix(c(rowMeans(ceres.tp53)))
tp53.prob.mean = as.matrix(c(rowMeans(prob.tp53)))
```

* For TTN:
```{r}
list.ttn = unique(subset(mutations.all, mutations.all$Hugo_Symbol == "TTN"))
cells.ttn = c(list.ttn$DepMap_ID)
exp.ttn = exp.clean[,which(colnames(exp.clean) %in% cells.ttn)]
copy.ttn = copy.clean[,which(colnames(copy.clean) %in% cells.ttn)]
ceres.ttn = ceres.clean[,which(colnames(ceres.clean) %in% cells.ttn)]
prob.ttn = prob.clean[,which(colnames(prob.clean) %in% cells.ttn)]
ttn.exp.mean = as.matrix(c(rowMeans(exp.ttn)))
ttn.copy.mean = as.matrix(c(rowMeans(copy.ttn)))
ttn.ceres.mean = as.matrix(c(rowMeans(ceres.ttn)))
ttn.prob.mean = as.matrix(c(rowMeans(prob.ttn)))
```

# Data visualization

We did boxplots for visualization of whole expression and CN matrices as well as MT-ND5 expression and CN. Also heatmaps for whole mutation, CN, expression, CERES and probability matrices (with and without 0 values).
Packages: pheatmap, grid

Expression matrix (only a few overexpressed genes, a lot of deleted genes) :
```{r}
library(pheatmap)
library(grid)
setHook("grid.newpage", function() pushViewport(viewport(x=1,y=1,width=0.9, height=0.9, name="vp", just=c("right","top"))), action="prepend")
#pheatmap(exp.clean, show_rownames = F)
setHook("grid.newpage", NULL, "replace")
grid.text("cell lines", y=-0.07, gp=gpar(fontsize=16))
grid.text("genes", x=-0.07, rot=90, gp=gpar(fontsize=16))

setHook("grid.newpage", function() pushViewport(viewport(x=1,y=1,width=0.9, height=0.9, name="vp", just=c("right","top"))), action="prepend")
#pheatmap(exp.clean.w0, show_rownames = F)
setHook("grid.newpage", NULL, "replace")
grid.text("cell lines", y=-0.07, gp=gpar(fontsize=16))
grid.text("genes", x=-0.07, rot=90, gp=gpar(fontsize=16))
```
Code for other matrices analogous to the one for the expression matrix. 
Observations: for CERES and probability matrix only a few genes seemed to be essential.

# Data reduction

## Additional cleanup beforehand


Rows containing 0 in matrices were removed, and gene data availability was compared again to ensure all matrices had the same dimension.

```
sum(exp.clean == 0)
exp.clean.w0 <- exp.clean[!(apply(exp.clean, 1, function(y) any(y == 0))),]
sum(exp.clean.w0 == 0)

sum(copy.clean == 0)
copy.clean.w0 <- copy.clean[!(apply(copy.clean, 1, function(y) any(y == 0))),]
sum(copy.clean.w0 == 0)

sum(ceres.clean == 0)
ceres.clean.w0 <- ceres.clean[!(apply(ceres.clean, 1, function(y) any(y == 0))),]
sum(ceres.clean.w0 == 0)

sum(prob.clean == 0)
prob.clean.w0 <- prob.clean[!(apply(prob.clean, 1, function(y) any(y == 0))),]
sum(prob.clean.w0 == 0)

dim(copy.clean.w0) == dim(exp.clean.w0)
gene.data.ex = c(rownames(exp.clean.w0))
copy.clean.w0 = copy.clean.w0[-which(rownames(copy.clean.w0) %!in% gene.data.ex),]
genes.clean.w0 = rownames(exp.clean.w0)
ceres.clean.w0 = ceres.clean.w0[-which(rownames(ceres.clean.w0) %!in% genes.clean.w0),]
prob.clean.w0 = prob.clean.w0[-which(rownames(prob.clean.w0) %!in% genes.clean.w0),]
genes.clean.w0 = rownames(prob.clean.w0)
exp.clean.w0 = exp.clean.w0[-which(rownames(exp.clean.w0) %!in% genes.clean.w0),]
copy.clean.w0 = copy.clean.w0[-which(rownames(copy.clean.w0) %!in% genes.clean.w0),]
ceres.clean.w0 = ceres.clean.w0[-which(rownames(ceres.clean.w0) %!in% genes.clean.w0),]
rm(gene.data.ex)
```
dimensions: 11545x28

# Principal component analysis (PCA)

## Data cleanup


The first step was to determine our four most prominent driving mutations, which we had already done before. 
Most prominent DMs: TP53, TTN, MT-ND5, MUC16

After that we separated the cell lines from the mutation matrix which contained one specific mutation. This was done in order to determine other genes that were also mutated in the presence of this specific DM. Since there were a few thousand mutated genes for each DM, the ones were "IsDeleterious = TRUE" were extracted.

For TP53:
```{r}
mutations.tp53 = rbind(relevant.mutations$`ACH-000036`,relevant.mutations$`ACH-000040`, relevant.mutations$`ACH-000098`, relevant.mutations$`ACH-000208`, relevant.mutations$`ACH-000215`, relevant.mutations$`ACH-000137`, relevant.mutations$`ACH-000152`, relevant.mutations$`ACH-000591`, relevant.mutations$`ACH-000673`, relevant.mutations$`ACH-000231`, relevant.mutations$`ACH-000368`, relevant.mutations$`ACH-000376`, relevant.mutations$`ACH-000445`, relevant.mutations$`ACH-000464`, relevant.mutations$`ACH-000469`, relevant.mutations$`ACH-000570`, relevant.mutations$`ACH-000571`, relevant.mutations$`ACH-000623`, relevant.mutations$`ACH-000673`, relevant.mutations$`ACH-000738`, relevant.mutations$`ACH-000756`, relevant.mutations$`ACH-000819`, relevant.mutations$`ACH-000128`)
mutations.tp53 = select(mutations.tp53, c(2,21, 36))
mutations.tp53 = subset(mutations.tp53, mutations.tp53$isDeleterious == "TRUE")
```

The same steps were done like this for all other prominent mutations (TTN, MT-ND5, MUC16).

After that we detemrined the remaining genes and extracted them from the CERES matrix in order to continue working just with them.

Same method used for all mutations mentioned above. Example for TP53:
```{r}
list.tp53.genes = unique(subset(mutations.tp53))
genes.tp53 <- c(list.tp53.genes$Hugo_Symbol)
ceres.tp53.genes <- ceres.clean[which(rownames(ceres.clean) %in% genes.tp53),]
```

## Determining potential second site targets (SSTs) through correlation tests: Is there a correlation between DM and other mutations in the cell? 


### Checking data distribution in order to determine which correlation test to apply


Parametric correlation tests (e.g. Pearson correlation) need normally distributed data. If that is not the case, apply non-parametric tests (e.g. Spearman correlation or Wilcoxon Rank sum test).

Methods to determine the type of distribution: qq-plots (visual determination), Shapiro-Wilk-test.

* exemplary qq-plot of CERES scores of all genes of cell line ACH-000036


```{r}
qqnorm(ceres.tp53.genes$`ACH-000036`, main="QQ-Plot of CERES scores of all genes of cell line ACH-000036")
qqline(ceres.tp53.genes$`ACH-000036`, datax = FALSE, distribution = qnorm,
        probs = c(0.25, 0.75), qtype = 7)
```

Observation: qq-plot shows curve that deviates from a linear curve. 
Conclusion: CERES scores are not normally distributed. 


### Shapiro-Wilk-Test (exemplary for one cell line)


```{r}
shapiro.test(ceres.tp53.genes$`ACH-000036`)
```

#### Results: 

data: ceres.tp53.genes$ACH-000036 W = 0.85504, p-value < 2.2e-16

#### Interpretation: 

p-value < 0.05 --> CERES scores of all genes of cell line ACH-000036 are not normally distributed.

#### Using apply-function to determine the distribution of all cell lines.


Creating a matrix that contains all mutated genes of cell lines
```{r}
ceres.allDM.genes=rbind(ceres.tp53.genes, ceres.ttn.genes, ceres.mtnd5.genes, ceres.muc16.genes)
```
```{r}
lapply(ceres.allDM.genes,shapiro.test)
```

#### Results:

All cell lines show p-values < 0.05 --> no normal distribution.


### Perform non-parametric tests to determine the correlation of the mutated genes to the DMs in order to find potential SSTs.


#### Spearman correlation

We used this test to correlate the CERES scores of every gene across all cell lines belonging to one specific DM to the DM.

In order for this to work we transposed all matrices to make cell lines rows and genes columns.

```{r}
t(ceres.tp53.genes)->ceres.tp53.genes_t
t(ceres.ttn.genes)->ceres.ttn.genes_t
t(ceres.muc16.genes)->ceres.muc16.genes_t
t(ceres.mtnd5.genes)->ceres.mtnd5.genes_t
```

We then selected the columns (CERES score of on gene across all cell lines) and calculated the correlation to the DM (one specific column). We performed this for all genes in the matrix using lapply.

Exemplary correlation test for one specific gene:
```{r}
cor(ceres.tp53.genes_t$ABCA13, ceres.tp53.genes_t$TP53, method = "spearman")
```
It was necessary to generate a correlation matrix including the correlation coefficients between all genes in the matrix, in order to solve an error in the last step.

```{r}
cor.ceres.tp53.genes_t<-cor(ceres.tp53.genes_t, method="spearman")
```

We then extracted one specific column from this matrix because it was very large and contained a lot of information that was irrelevant for us.

```{r}
cor.ceres.tp.53.only<-cor.ceres.tp53.genes_t[1:734,642]
```
cor.ceres.tp.53.only includes correlation coefficients of all genes to TP53. The matrices for the other DMs were created using an analogous method.

#### Determination of p-values to get correlation matrices with significance levels (statistical statements)


Packages: Hmisc

The function rcorr(x, type = c("pearson", "spearman")) can be used to compute the significance levels for Spearman an Pearson correlations. 

We calculated the significance levels for TP53:
```{r}
sig.cor.ceres.tp53.genes_t<-rcorr(as.matrix(ceres.tp53.genes_t), type="spearman")
View(sig.cor.ceres.tp53.genes_t$r)
```

Extracted the relevant column:
```{r}
sig.cor.ceres.tp53.only<-sig.cor.ceres.tp53.genes_t$r[1:734, 642]
```

And did the same for the other DMs.

#### P-values and hypothesis testing


A p-value is the probability of obtaining a larger (one-sided upper tail), a smaller (one-sided lower tail) or a more extreme value (two-sided or two-tailed) value of the statistics if H0 is valid. Following this logic, a low p-value means that H0 is invalid with a high probability.

We need a significance level alpha to evaluate our p-values in order to identify potential SSTs --> p < ?? : H0 is invalid and can be rejected, the observed effect is significant and H1 is statistically proven.

?? = 0.05 is often used as a standard value. We chose to apply the same value to evaluate our correlation results as well as H0 and H1.

#### Formulating our H0 and H1 hypothesis:


* H0: The correlation of a mutated gene and the DM is not significant --> not potential SST

* H1: The correlation of a mutated gene and the DM is significant --> potential SST

We defined a threshold for the p-values to identify all the genes that are correlated to the DMs with a high probability.

* TP53
```{r}
sig.cor.ceres.tp53.only[abs(sig.cor.ceres.tp53.only) > 0.05]<- NA
``` 
Only significant p-values remain --> all genes that are NA are no potential SSTs; all genes where H0 cannot be rejected are defined as NA
```{r}
sst.tp53<-na.omit(sig.cor.ceres.tp53.only)
```
Returns a matrix that contains all potential SSTs that we can compare to literature afterwards

* TTN
```{r}
sig.cor.ceres.ttn.only[abs(sig.cor.ceres.ttn.only) > 0.05]<- NA
sst.ttn<-na.omit(sig.cor.ceres.ttn.only)
```

* MUC16
```{r}
sig.cor.ceres.muc16.only[abs(sig.cor.ceres.muc16.only) > 0.05] <- NA
SST.muc16<-na.omit(sig.cor.ceres.muc16.only)
```

* MT-ND5
```{r}
sig.cor.ceres.mtnd5.only[abs(sig.cor.ceres.mtnd5.only) > 0.05] <- NA
SST.mtnd5<-na.omit(sig.cor.ceres.mtnd5.only)
```


### Comparison to literature

#### For TP53: 

Paper: Synthetic sickness or lethality points at candidate combination therapy targets in glioblastoma.  (Szczurek, Ewa; Misra, Navodit; Vingron, Martin)

* PLK-1: well-known interaction between PLK-1 and TP53, which is not present in our data. It does not show a significant correlation between TP53 and PLK-1 because PLK-1 does not appear in the remaining mutated genes. 

* SLC1A5: one of the top plausible SSL pairs with significant impact on overall survival in GBM when knock-down.  SLC16A5, SLC27A6, SLC34A1, SLC3A2 and SLC6A9 appear to be significantly correlated to the TP53 mutation. Are these genes maybe variants of SLC1A5? Or are they completely different genes?

Paper: Correlation of Somatic Mutation and Expression Identifies Genes Important in Human Glioblastoma. (Masica, David L.; Karchin, Rachel)

* MDM2: all genes except MDM2 are overexpressed if TP53 is mutated, but it is overexpressed by TP53 wt. Our data does not show a significant correlation between MDM2 and TP53.

We then tested our data for over-expressions:

* DBF4: DBF4 over-expressions have been specifically linked to linked to TP53 status. Our data does not show a significant correlation between DBF4 and TP53.

* TCP1: Overexpressed in context of GBM when TP53 is mutated. Our data shows no significant correlation between TCP1 and TP53.

* BUB3, HSPA14, TFAM, GFTP1, DERL1, SND1, ALDH1B1, RECK, UGHD, AOF2 (LSD1), GADD45G and CERK (ceramide kinase) could be other SSTs  according to literature, but through our investigation we were not able to verify these potential SST.

#### For our other DMs

There are no potential SSTs for TTN, MT-ND5 and MUC16 according to literature, because these are not common driving mutations. 


# Multiple linear regression

## Creating a model

With a multiple linear regression we intended to create a model which could predict a SST deriving from a DM. This turned out not to work and we decided to create a model for each expression, copy number, CERES score and probability, each based on the other values.

We calculated the mean of expression, copy number, CERES score and probability throughout all cell lines and combined all values in a matrix. We then performed the multiple linear regression.

```{r}
mlr.mat = as.data.frame(cbind(rowMeans(exp.clean.w0), rowMeans(copy.clean.w0), rowMeans(ceres.clean.w0), rowMeans(prob.clean.w0)))
colnames(mlr.mat) = c("expression", "copynumber", "ceres", "probability")

summary(lm(expression ~ ., data = mlr.mat)) 
summary(lm(copynumber ~ ., data = mlr.mat))
summary(lm(ceres ~ ., data = mlr.mat)) 
summary(lm(probability ~ ., data = mlr.mat)) 
```
* expression -> r^2 = 0.1563
* copynumber -> r^2 = 0.003437
* CERES score -> r^2 = 0.9352
* probability -> r^2 = 0.9358

## Testing our multiple linear regression model

Packages: caTools

The intent with this testing was to use values the model had never seen before and to compare them with the real values. All steps showed below were performed with all models. Exemplary showing steps with expression model.

First we splitted the multiple linear regression matrix into 4/5 training set and 1/5 testing set. 
```{r}
library(caTools)
set.seed(123) #initialize the random numbers
split.exp = sample.split(mlr.mat$expression, SplitRatio = 0.8) #split the mlr.mat into 4/5 Training and 1/5 Testing expression values
split.exp = as.data.frame(split.exp) #converting split.exp to a data frame for further analysis
training_set_exp = subset(mlr.mat, split.exp == TRUE) #use labels to get training data
test_set_exp = subset(mlr.mat, split.exp == FALSE) #dim(test_set_exp) will give you 2309 --> 11545/5*1 = 2309 --> train/test split worked
```

Observation: the training/test set splitting did not work for the copy number matrix.

We then fitted the multiple linear regression to the training set.
```{r}
exp.regressor = lm(expression ~ ., data = training_set_exp)
```

Then we predicted the test results based on data that our model had never seen before. This is very useful to evaluate the performance of the model.
```{r}
exp_pred = predict(exp.regressor, newdata = test_set_exp) 
test_set_exp$Prediction = exp_pred #add predictions to mlr.mat 
test_set_exp #now a comparison of the Predictions (last column) with the real values for the expression (1st column) is possible 
```

## Visualizing real values against test values

To better visualize and evaluate our models we plotted the predicted values against the real values for expression, CERES score and probability.

For the CERES score model:
```{r}
plot.ceres.m <- melt(test.set.ceres$ceres)
a <- melt(test.set.ceres$Prediction)
colnames(plot.ceres.m) <- "CERES"
rownames(plot.ceres.m) = rownames(test.set.ceres)
colnames(a) <- "Prediction"
plot.ceres.m <- cbind(plot.ceres.m,a)
plottingData.ceres <- melt(plot.ceres.m)

ceres_plot <- ggplot(data = plottingData.ceres, aes(x=value, fill=variable)) + 
  geom_density(alpha=.3) +
  ggtitle(paste0("Performance evaluation Lin.Reg. CERES score")) +
  ylab("Density") +
  xlab("CERES score values") +
  theme_bw(base_size = 7) +
  theme(legend.position="bottom",
        legend.direction="horizontal",
        plot.title = element_text(hjust = 0.5),
        axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1),
        legend.title= element_blank(),
        axis.title.x = element_blank(),
        strip.text.y = element_text(angle = 0))
```

For the expression model:

```{r}
plot.exp.m <- melt(test_set_exp$expression)
a <- melt(test_set_exp$Prediction)
colnames(plot.exp.m) <- "Expression"
rownames(plot.exp.m) = rownames(plot.ceres.m)
colnames(a) <- "Prediction"
plot.exp.m <- cbind(plot.exp.m,a)
plottingData.exp <- melt(plot.exp.m)

exp_plot <- ggplot(data = plottingData.exp, aes(x=value, fill=variable)) + 
  geom_density(alpha=.3) +
  ggtitle(paste0("Performance evaluation Lin.Reg. expression")) +
  ylab("Density") +
  xlab("Expression values") +
  theme_bw(base_size = 7) +
  theme(legend.position="bottom",
        legend.direction="horizontal",
        plot.title = element_text(hjust = 0.5),
        axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1),
        legend.title= element_blank(),
        axis.title.x = element_blank(),
        strip.text.y = element_text(angle = 0))

```

For the probability model:
```{r}
plot.prob.m <- melt(test.set.prob$probability)
a <- melt(test.set.prob$Prediction)
colnames(plot.prob.m) <- "Probability"
rownames(plot.prob.m) = rownames(test.set.prob)
colnames(a) <- "Prediction"
plot.prob.m <- cbind(plot.prob.m,a)
plottingData.prob <- melt(plot.prob.m)

prob_plot <- ggplot(data = plottingData.prob, aes(x=value, fill=variable)) + 
    geom_density(alpha=.3) +
     ggtitle(paste0("Performance evaluation Lin.Reg. probability")) +
     ylab("Density") +
     xlab("Probability values") +
    theme_bw(base_size = 7) +
     theme(legend.position="bottom",
           legend.direction="horizontal",
           plot.title = element_text(hjust = 0.5),           axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1),
           legend.title= element_blank(),
           axis.title.x = element_blank(),
           strip.text.y = element_text(angle = 0))
```

Observation: No plot for copynumber because training/test split did not work.

Looking at the expression graph, it becomes clear that the model does not work. The CERES model and the probability model are both similar in the sense that the curves are better that the curve for the expression model. This however does not mean that the models are good for predicting CERES scores and knock down probability.








